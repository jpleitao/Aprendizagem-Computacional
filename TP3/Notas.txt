FIXME: Por enquanto estou a assumir que na classificação em grupo o número de elementos iguais para se poder classificar está definido internamente....

FIXME: Nos resultados apresentar sensibilidades e calcular erros, ponto a ponto (abordagem inicial, para classificação individual; e segunda abordagem, para classificação em grupo)

FIXME: Na rede "layrecnet" estou a considerar um único neurónio na camada de saída!!!! - À partida diria que é suposto considerar isso, porque a nossa saída só tem dois valores, 0 ou 1, logo só precisamos de um neurónio

Redes neuronais a implementar:
- Feedforward Net (feedforwardnet) normal, com duas ou três camadas -- Ver se usamos o newff ou o feedforwardnet ou as duas!!!
- Layer Recurrent Network: net=layrecnet(layerDelays,hiddenSizes,trainFcn)
- Radial Basis Function Network (RBF): net = newrb(P,T,goal,spread,MN,DF)
- Eventualmente usar também um perceptrão (newp)??

Para as redes neuronais criar campos de:
- Epochs
- Goal
(Não esquecer Perform Function e Show, mas esses não pedir ao utilizador)
1)Layer Recurrent Network:
	- Train Function
	- Hidden Layer Size
	- Layer Delays
2)Radial Basis Function
	- Goal
	- Spread
3)feedforwardnet
	- Hidden Size
	- Train Function
4)newff
	- Vector representativo do input
	- Vector representativo do output
	- Tamanho das camadas S1...S(N-1)

Train Functions:
- Levenberg-Marquardt backpropagation (trainlm)
- Gradient Method (traingd)


=================================================================================================================================================



Usar função divideind para dividir os exemplos em casos de treino e teste

No entanto, ao fazermos a divisão dos dados, podemos ter nos casos de treino poucos exemplos de crises o que leva à criação de redes especializadas em detectarem classes não ictais (situações normais), possivelmente incapazes de detectarem com sucesso a classe ictal. Uma forma de resolver este problema passa por reduzir a dimensionalidade, sub-amostrando os dados de treino por forma a considerar um número de casos da classe ictal da mesma ordem de grandeza do número de casos da classe não ictal (NOTA: Pode conduzir à perda da interpretabilidade dos dados de entrada! -- Referir isso no relatório).

NOTA: Esta sub-amostragem só deve ser feita para o conjunto de dados de treino, pois é com esses que a rede vai aprender! Nos outros podemos ter à vontade números muito diferentes de casos da classe ictal e não ictal!!!

Testar variações da distribuição dos casos de treino (70-30; 65-35; etc) -- Variar redução da dimensionalidade

Como fazer então esta redução da dimensionalidade/sub-amostragem??

	1) Análise de Correlação
		Selecção de parâmetros (entradas) com base na sua correlação e informação mútua
		Usar função corrcoef do Matlab: Valor na gama [-1,1]. Se -1 ou 1 então é pefeitamente correlacionado (interessa). Se for 0 é completamente descorrelacionado (não interessa)

	2) Pesquisa Para a Frente
		Cada parâmetro é adicionado isoladamente e o resultado obtido é avaliado segundo um determinado critério (geralmente erro). O parâmetro que conduz ao melhor resultado é adicionado.

	3) Pesquisa Para Trás
		O processo é iniciado com todo o conjunto de todos os parâmetros, eliminando um deles de cada vez, de uma forma semelhante à pesquisa para a frente
	
	4) Análise de Componentes Principais
		[PC, reducedData, EIG]=princomp(X); --> Usar [COEFF, SCORE, LATENT] = pca(X) com os mesmos valores de retorno e chamada
		PC = Componentes principais
		reducedData – transformação dos dados X
		EIG – valores próprios por ordem decrescente

		Logo, devem-se escolher os primeiros valores próprios até um dado valor (Ex: Dimensão 5, escolhemos os 3 primeiros)